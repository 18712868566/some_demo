#使用canvas绘图

###**绘图前提**

1. 先有一个canvas的html标签：```<canvas></canvas>```
2. 标签通常请客下，只有height和width两个宽高属性，  
   例如：```<canvas width='200' height='200'></canvas>  ```
   表示这个画布是宽高是200px，他所在的范围，就是画图的范围（超出部分无法绘图）
3. 前获取的canvas标签所在的DOM，和正常获取一个DOM方法一致（比如document.getElementById()）
4. 假设之前获取的DOM被赋给变量canvas，然后获取绘图用的渲染上下文，具体方法是：  
   ```var ctx = canvas.getContent('2d');```  
   这个ctx就是我们需要的绘图用的对象。  
   **调用接口时，如无特殊声明，都指的是通过这个ctx对象来调用**
   
###**0. 填充颜色和线条颜色**

###0.1 线条颜色####

**ctx.strokeStyle = color**

    1. 指线条，即stroke类方法描绘的轮廓的颜色；
    2. 该颜色不影响fill类方法填充时的颜色；

###0.2 填充颜色####

**ctx.fillStyle = color**

    1. color的类型可以是类似#000，或者rgb(0,0,0)，或者是rgba(0,0,0,0)这样形式；

**ctx.fillStyle = gradient**

    1. 用于使用渐变色，分为线性渐变和镜像渐变；
    2. 值是一个特殊对象，通过ctx来调用对应的API（线性或者镜像）创建；

镜像渐变：  
ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);

    1. 简单来说，通过两个圆来形成渐变背景图形；
    2. 第一个圆是渐变起始，第二个圆是渐变终止；
    3. 根据两个圆的相对位置关系不同，有三种情况，他们表现出的图案样式有所区别：
    3.0 染色时，范围大致可以分为以下几部分：最外层染色范围 > 次外层起始圆（终止圆）外 > 渐变区 > 最内层终止圆（起始圆）内
    3.1 【起始圆在终止圆内】：
        最内层：起始圆内全部被染成起始色;
        渐变区：起始圆最外围和终止圆的部分是渐变范围，最终渐变为终止颜色；
        最外层：终止圆外，绘图范围内是终止颜色；
        
    3.2 【起始圆在终止圆外】；
        最内层：终止圆内全部被染成终止色；
        渐变区：终止圆外，起始圆内为渐变区，渐变方向是从起始圆 -> 终止圆；
        最外层：起始圆外，染色范围内是起始色；
        
    3.3 【起始圆和终止圆相交】：
        比较复杂，想要理解，可以按照我说的画个图；
        首先，画起始圆和终止圆两个圆，他们会有一部分相交；
        此时，连接两个圆的圆心，然后再画两条线，这两条线线不与圆心连线（线段）相交，且每条线和每个圆有且只有一个交点；
        
    如图，图中左边的为起始圆，右边的为终止圆，起始颜色为红色，终止颜色为黄色，渐变中间色是绿色（即红-绿-黄）
        
![image](https://github.com/qq20004604/some_demo/blob/master/canvas/01.png)
        
        这样画出来的两条线（AC和BD），
        如果平行，则将染色区域划分为最多三部分：
        ①两条线之间的区域（两个圆存在的区域，图中MX和NY之间的区域）；
        ②③两条线以外的区域（以上和以下三个区域，MX线左上区域和NY左下区域）；
        如果相交，则将染色区域划分为最多四个部分：
        ①两个圆心所在区域；
        ②③④其他三个区域；（即多一个XM和YN线相交后延长线所包含区域）
        
        无论是哪种情况，实际染色区域只有①号区域，即两个圆圆心所在区域（即图中MNYX区域），该区域以外是为透明（不染色）。
        
        此时，实际染色区域可以分为以下区域：（先找到两条线和两个圆所相交的四个点）
        ①AB（左边弧）+DE（左边弧）+AC+BD共同框住的区域：（即图中ABDC四个点包含起来的F区域）
        ②这个区域一侧，靠近起始圆所在的区域；（即图中AMNB包裹起来的E区域）
        ③这个区域另一侧，靠近终止圆所在的区域 + 终止圆区域（即CDYX包含起来的G区域）；
        
        其中，②区域是起始色（E红），③区域是终止色（G黄）；
        剩下的是F区域，为渐变色区域


    4. 创建方法：
    4.1 先通过var gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);来创建一个镜像渐变的对象；
    4.2 x0和y0表示起始圆的圆心坐标，r0表示起始圆的半径；
    4.3 x1,y1表示终止圆的圆心坐标，r1表示终止圆的半径；
    4.4 设置颜色：gradient.addColorStop(number, color);
    4.5 number表示在渐变区域的该位置，颜色是什么颜色；
    4.5.1 当值为0时为初始色，值为1时为终止色；
    4.5.2 当0~1之间时，例如0.4，则表示从渐变区域的起始位置，往终止位置移动总距离的40%处的颜色为color
    4.6 color可以是"#000"这样或者rgb或者rgba，类型是字符串；
    4.7 然后使用ctx.fillStyle = gradient;赋值颜色即可；
    
线性渐变：  
ctx.createLinearGradient(x0, y0, x1, y1)

    1. 和镜像渐变类似，只不过线性渐变是从某位置渐变到另外一个位置（点到点，镜像渐变是圆到圆）；
    2. x0和y0是渐变起始坐标；
    3. x1和y1是渐变终止坐标；
    4. 具体来说，可以这么理解：
    4.1 在起始坐标和终止坐标之间，连一条线段；
    4.2 在起点和终点，分别画一条直线，这两条直线平行并且垂直于这条线段；
    4.3 这两条直线之间的区域，就是渐变区域；
    4.4 起点的直线的颜色为起始颜色，终点的直线的颜色为终止颜色；
    4.5 不能理解两条线中间的颜色的人（自己去写写代码就懂了，解释起来好麻烦）；
    5. 设置颜色同镜像渐变；

**ctx.fillStyle = pattern**

    1. 用于将图片作为背景色
    2. 请注意，由于图片可能没有加载好，所以务必确认画图时，需要使用的图片已经加载完毕；
    3. 需要调用API创建一个对象（在创建的时候需要加载一个HTML图片元素作为参数）;
    4. 可以设置x、y轴上的重复属性；
    5. 将这个对象赋值给ctx.fillStyle
    示例代码：
        var c = document.getElementById("circle3");
        var ctx = c.getContext("2d");
        var img = new Image();
        img.src = "./02.png";
        img.onload = function () {
            var pat = ctx.createPattern(img, 'repeat');
            ctx.fillStyle = pat;
            ctx.beginPath();
            ctx.moveTo(60, 50);
            ctx.arc(60, 50, 40, 0, 2 * Math.PI);
            ctx.fill();
        }
    6. 以上代码画出了一个圆，这个圆的内容是图片，关键在于显示图片哪个区域；
    7. 具体而言，这个图片的位置，由canvas决定，可以理解为，在调用createPattern时，决定该图片的url和repeat属性；
    8. 其中第一个参数的图片的url是canvas的background-image的url属性值；
    9. 第二个参数是background-repeat的值；
    10. 而染色时，有一个染色区域，这个染色区域将canvas上对应位置的区域图片显示出来；
    11. 而图片本身位置是相当于canvas标签是确定的（不受绘图时设置的属性所影响）；
    12. 即使改变HTML图片元素的margin属性、background-position属性或者其他属性都无法影响；
    13. 如果有办法，请加我QQ：20004604，或者发邮件到20004604@qq.com告诉我，谢谢。

###**1. 绘制矩形**

**fillRect(x, y, width, height)**

    1. 绘制一个矩形；
    2. 该矩形为填充满的；
    3. x和y指矩形左上角，相对于画布的坐标。
    4. x和y的标准范围是x:0~width, y:0~height
    5. 参数是number类型，不是字符串类型；
    6. 示例：ctx.fillRect(10, 20, 50, 50);
    7. 关于参数的解释，下同；

**strokeRect(x, y, width, height)**

    1. 绘制一个矩形；
    2. 该矩形只有边框；
    3. 该矩形内部透明；

**clearRect(x, y, width, height)**

    1. 清除一个矩形区域；
    2. 该矩形区域内内容被清除，变为透明；


###**2. 绘制路径**

解释：

    1. 简单来说，是绘制几条边，然后这几条边围城一个封闭图形，就完成了一个图形；
    2. 绘制过程中，建议不要去做其他事，原因见流程3-5；
    3. 开始绘制：ctx.beginPath();
    4. 绘制中：略，此时只有线条，但是没有图形（轮廓也没有，线条是看不见是，只是为最后一步做准备）；
    5. 结束绘制：ctx.fill()或者ctx.stroke()，前者填充满图形，后者只有线条轮廓；
    6. 因为是一个封闭的过程，所以虽然也可以在绘制过程中去完成其他的绘图（不是所有都可以），但是这样不利于维护，因此还是建议分开写；

API：

**beginPath()**

    1. 生成一条路径；
    2. 这条路径是母路径，在绘制过程中，会生成很多条子路径，
    3. 子路径最终构成的就是我们想要的图形
    4. 另外，虽然这个方法可以多次调用（至少在我的浏览器可以），但是建议还是按照上面流程来完成，这样至少代码可维护性好，不易发生BUG；

**closePath()**

    1. 闭合路径；
    2. 简单来说，就是从线条绘制到当前位置时的坐标，和起点连线；
    3. 起点是指调用beginPath后，移动到的第一个点；
    4. 这个点可能是moveTo的参数，也可能是lineTo的参数，或者其他。但总之，第一条路径一般视为于moveTo

**stroke()**

    1. 描绘轮廓；
    2. 通俗的说，就是你线条怎么画的，他给你把线条染色（没染色前是看不见的）；
    3. 这个只染轮廓不填充；

**fill()**

    1. 填充线条；
    2. 这个填满被线条包围的区域；
    3. 重点是包围的区域，比如你画个五角星（线条穿来穿去），那么五角星内部的五边形和五个三角形会被填充，外部不会；
    4. 在调用beginPath()之前，染色视为最后一次的fillStyle的颜色；

**moveTo(x, y)**

    1. 移动画笔；
    2. 移动过程中不会产生线条；
    3. 可以把这个理解为把笔抬起来，然后移动到新地方后再把笔放下来；

**lineTo(x, y)**

    1. 画一条直线；
    2. 起始位置是当前笔的位置；
    3. 参数是笔移动后的终点位置（相对于画布的坐标）；
    4. 终点位置是下一次画图时，笔的起始位置；

**arc(x, y, radius, startAngle, endAngle, anticlockwise)**

    1. 画一个圆弧；
    2. x和y是圆心相对于画布的坐标；
    3. radius是圆的半径；
    4. startAngle和endAngle是起始角度和终止角度，单位是弧度，2 * Math.PI是360度；
    5. anticlockwise表示顺逆时针，false为顺时针，true为逆时针；
    6. 起始坐标是圆的正右方位置

###**3. 画矩形**

0.颜色

    使用API：fillStyle(color)来完成

1.画未填充的矩形

    1. 画未填充的矩形还是很简单的；
    2. 首先确定矩形左上角顶点的位置；
    3. 再确定矩形的宽高；
    4. 使用strokeRect(x, y, width, height)，将数据输入即可；
    
2.画填满的矩形

    1. 画未填充的矩形还是很简单的；
    2. 首先确定矩形左上角顶点的位置；
    3. 再确定矩形的宽高；
    4. 使用fillRect(x, y, width, height)，将数据输入即可；（和上面的区别在这一步）
    
3.画内有空隙的矩形

    1. 典型来说，比如外边有个大矩形，内部有个小矩形，两个矩形之间被染色，而内部小矩形是透明的；
    2. 先按照2的方式画个矩形；
    3. 然后使用clearRect(x, y, width, height)清空小矩形区域的图形即可；
    
###**4. 画圆形**

0.颜色

    使用stroke()（轮廓颜色）或者fill()（填充颜色）完毕后，再更换颜色开始下一次绘图
    
1.画圆形

    0. 调用ctx.beginPath()开始画路径;
    1. 确定圆心坐标和圆半径
    2. 调用ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)方法
    3. x和y填圆心坐标，radius填半径；
    4. startAngle填开始角度，endAngle填结束角度，注意，角度为0时，起始点为圆心正右方；
    5. 角度为弧度，弧度和角度的换算是360角度 = 2π弧度；
    6. 最后一个参数不填或者为false时，表示默认顺时针绘图，否则为逆时针绘图；
    7. 可能会产生一个bug，原因和解决方式见下面画两个圆

2.画两个圆形

    1. 大部分和1相同；
    2. 正常流程是通过beginPath()——》画一个圆——》fill()或者stroke()，重复这个流程画下一个圆；
    3. 如果不是这样的流程的话，那么需要看第四条
    4. 需要使用moveTo来将画笔从第一个圆的终止处，移动到第二个圆画图时的起始处（你要画图的圆弧的起始处），然后再开始画下个圆；
    5. 圆形就调用fill()，圆弧就调用stroke()
    6. 如果非满圆的话，注意结果不是扇形，是一个圆被一刀切掉一部分后的样子（具体自己画一下就理解了，或者看DEMO）；

3.画圆弧

    1. 大部分和1相同；
    2. 需要注意的是笔记的轨迹；
    3. 在beginPath()后可以直接开始画圆弧，因为自带moveTo效果；
    4. 画完后直接调用stroke()方法来收尾给线条染色；
    5. 连续画圆弧的话，建议走beginPath()——》画一个——》stroke()，然后下一轮的方式，比较稳妥；

4.画扇形

    1. 大部分和画圆相同；
    2. 需要先手动移动画笔到圆心，再调用arc方法来画图，不然画出来的就不是一个扇形；
    3. 参照DEMO里第二个图和第三个图的区别，就是圆和扇形的区别了；

###**5. 将图片绘制到画布之上**

解释：

    1. 简单来说，就是将一张图的某个区域，画到画布上的某个区域；
    2. 和ctx.fillStyle = pattern不同的是，pattern是将图片作为背景，该背景位置是固定的，画图只是显示那背景某个区域；
    3. 而本方法画图是取图的全部/一部分（比如400x400的，取他(x:200,y:250,width:50,height:100)区域的图；
    4. 然后放在画图的某个指定区域（如坐标x:100,y:200处），也可以缩放图片大小（比如变为width:300,height:200）；
    5. 运用场景示例：有一个人物八方向四帧动作图，在一个png图上，可以根据需要，只取其中一个，然后绘制到画布区域之中；

**ctx.drawImage(image, dx, dy)**

    1. 将图片完整绘制在画布的x, y坐标处；
    2. x, y是图片绘制时，其左上角位于画布的坐标，参数类型是Number（不是有px的字符串类型）；
    3. 不会对图片进行缩放（即保持图片本身大小）；
    4. image是图片HTML元素，例如通过document.getElementById()获取的HTML的image元素，或者是在JS中，通过new Image()创建的图片元素；
    5. 需要小心一件事，图片在创建后，并不会立刻从服务器下载完成，因此假如图片是后续加载的话，务必要等图片onload事件触发后，再进行绘图；
    6. 应对办法：提前将图片下载好，这样绘制的时候就不必担心图片未加载完成的问题了。

**ctx.drawImage(image, dx, dy, dWidth, dHeight)**

    1. 将图片绘制在画布的x, y坐标处；
    2. 本方法在上一个方法的基础上，增加了缩放功能，dWidth和dHeight表示绘制到画布上时，画布上图片的宽高；
    3. 具体来说，假如一个图片是100*100，dWith和dHeight是200*200，就相当于将图片缩放了200%；

**ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)**

    1. 取出图片的某个区域，然后绘制到画布的某个区域；
    2. dx, dy, dWidth, dHeight和上面2个API表示的内容是一样的；
    3. sx表示图片（即image）取图时的x坐标，sy表示y坐标，sWidth表示从sx开始取的图片的宽度，sHeight表示从sy开始，取的图片的高度；
    4. 示例：假如image的宽高是200*200，这四个参数的值依次是50,50,100,100的话，表示取图片x:50, y:50到x:150, y:150这个范围的区域；
    5. sWidth + sx的值或者sHeight + sy的值可以大于图片本身的宽高，在缩放时，会将超出部分计算在内进行缩放，超出部分视为透明，不会染色；
    6. sWidth和sHeight可以是负数，有效，计算时同样相加即可，同样可以框住一个矩形区域。

具体请参照DEMO：绘制图片.html

###**6. 写文字**

解释：

    1. 可以绘制空心文字或者实心文字；
    2. 在绘制前可以定义三种属性：
    3. 定义完属性（或使用默认的）后，绘制文字到画布上。

**ctx.font**

    1. 字体和字体大小，类型是字符串。
    2. 和font-family类似，只不过多了一个字体大小的设置。
    3. 示例："Bold 10px Arial"先取Bold字体，如果没有则取Arial字体。字体大小取12px.

**ctx.textAlign**

    1. 字体对其方式，类型是字符串；
    2. 取值有left, center, right三种。
    3. 相对于绘制时的坐标，决定文字的排版方式。
    4. 绘制时的坐标，位于文字的下方。即假如是左对齐，绘制时的坐标是文字的左下角的坐标。

**ctx.fillStyle**

    1. 实心文字的颜色，就像普通写颜色css属性那样写；

**ctx.strokeStyle**

    1. 空心文字的颜色；

**ctx.fillText(text, x, y [, maxWidth])**

    1. 填充实心文字；
    2. x，y表示写文字时，基准位置的坐标点。左对齐是文字左下，居中是文字中间下方，右对齐是文字右下；
    3. maxWidth可以不加，加的话，会压缩文字的宽度（高度不会变化），而不是超出部分不显示；

**strokeText(text, x, y [, maxWidth])**

    1. 填充空心文字（需要字体支持）；
    2. 其他和上面没区别；


###**7. 画布的读取和写入**

解释：

    1. 简单来说，就是通过一个API保存当前画布某部分区域的图案；
    2. 然后可以通过另外一个API来恢复保存时的图案，可以恢复到某个指定位置；
    3. 保存时，返回一个变量，这个变量是一个对象：
       他有width和height属性表示画布宽高；
       还有data属性，用于保存画布各个像素的状态；
       data属性是一个数组，其保存原理是通过每个像素的rgba属性来保存；
       因为rgba是4个属性，分别表示红、绿、蓝、透明度，值的范围是0~255（包括透明度，255表示不透明）；
       因此，每个像素占用数组中四个位置。
       然后这么做的，先取出坐标0,0点像素的四个属性，放在data属性数组中（此时data属性有四个元素）；
       然后再找出坐标1.0点像素的四个属性，再放进去（此时data属性中有八个元素）；
       然后放完画布上y=0的所有像素，再开始放y=1的所有像素，依次类推。
    4. 当已知data属性的存储原理时，可以通过修改data属性中，数组的元素的值，来修改存储的图像；
    5. 例如，将每个像素表示透明度的元素的值，修改为比较小的值，则存储的图像信息则变为半透明了（注意，此时原图像没又被改变）。
    6. 然后将修改后的存储的图像信息，通过api写入canvas，则新的图像变为半透明了。

**ctx.getImageData(x, y, width, height);**

    1. 简单来说，就是从画布的x，y坐标开始，取width宽height高的矩形区域的图像信息，返回一个对象；
    2. 这个对象就是存储了图像的宽高和所有像素的信息；
    3. 恢复图像时，需要使用这个方法返回的对象；
    4. 如果width或者height为0，则可能会抛出错误（应避免）；
    5. 返回值是一个ImageData对象；

**ctx.putImageData(imagedata, dx, dy)**

    1. 简单来说，就是将getImageData这个api返回的对象，通过这个api将存储的图像放置在起始坐标为（dx, dy）的地方；
    2. 设置时，图像的默认宽高是存储的原图像的宽高；
    3. 不会对存储的图像进行缩放；
    4. 图像绘制后，超出画布显示区域的，不会被显示。

**ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)**

    1. 简单来说，从原图像中，取出一部分，然后放到画布中。
    2. 具体来说，从原图像中，取出起始坐标为（dirtyX, dirtyY），宽高为（dirtyWidth, dirtyHeight）的矩形区域，然后绘制到画布上起始坐标（dx， dy）的区域；
    3. 同样，对图像绘制时，不会进行缩放；

DEMO见链接：[DEMO](url:http://htmlpreview.github.io/?https://github.com/qq20004604/some_demo/blob/master/canvas/Canvas%E7%BB%98%E5%88%B6%E4%B8%80%E5%BC%A0%E6%8A%98%E7%BA%BF%E5%9B%BE.html)

###**8. 将canvas转为图片可用的base64字符串**

解释：

    1. 简单来说，就是将canvas标签的画布内容，转为base64字符串；
    2. base64字符串作为img标签的src，是可以直接显示为图片的；

**canvas.toDataURL(type, encoderOptions)**

    1. 返回一个base64字符串；
    2. type可选，表示图片的转换目标类型，类型是字符串，默认是"image/png"，如果传的类型不支持/错误，也会自动转为默认的png格式的base64字符串； 
    3. encoderOptions可选，表示图片质量，范围0-1，1质量最好，如果超出取值范围，将会使用默认值0.92；
    4. 该字符串可以作为img标签的src的值，可以正常显示为图片。

注：

    1. 不知为何，在未设置strokeStyle时，我画一个矩形，我转为“image/jpeg”类型图片，输出的图片是纯黑色（见DEMO）：
    2. 不知为何，图片质量我设置后并没有生效（值为1和值为0.1转换出来的字符串，其值是相同的，见DEMO）；

DEMO见链接：[DEMO](url:http://htmlpreview.github.io/?https://github.com/qq20004604/some_demo/blob/master/canvas/%E5%B0%86Canvas%E8%BD%AC%E4%B8%BA%E5%9B%BE%E7%89%87.html)


