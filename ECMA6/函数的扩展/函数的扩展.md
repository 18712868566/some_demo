##函数的扩展

###0、一句话总结

<ol>
<li>函数参数有默认值的情况下，先取赋值，无则取默认值；</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>


###1、参数


####1.1、参数的默认值

#####1.1.1、是什么？
>function [name]([param1[ = defaultValue1 ][, ..., paramN[ = defaultValueN ]]]) { statements }3

简单来说，es6让js也可以像c++一样，给函数参数一个默认值了（原本默认值可以认为是undefined）。

具体解释的话：

1. 假如函数有参数a；
2. 该参数a有默认值；<br>
3. 调用该函数；<br>
3.1. 给a赋值了，a = 赋值的那个值；<br>
3.2. 没有给a赋值，a = 默认值；

```
function test(a = 1) {
    console.log(a);
}
test(); //1，取默认值
test(10);   //10，取传给他的值
```

#####1.1.2、自由给想要默认值的参数赋值
另外以下这种写法是可以的，即随意指定给某几个参数赋值（但是在c++里是不行的）
```
function test(a = 1, b) {
    console.log(a, b);
}
```

#####1.1.3、前置参数对后置可见，相反则不行
前置参数对后置参数是可见的：

···
function test(a = 1, b = a) {
    console.log(a, b);
}
test(5); //5 5，a被赋值5，然后b=a也等于5
test(10, 5);   //10 5，a被赋值10，b因为有赋值5，所以等于5而非等于a
···

但相反不行，并且可能出错

```
function test(a = b, b = 1) {
    console.log(a, b);
}
test(5); //5 1，a被赋值5，所以a=b不生效，b无赋值所以等于默认值
test(10, 5);   //10 5，分别被赋值10和5
test(); //Uncaught ReferenceError: b is not defined，后置参数对前置不可见
```

#####1.1.4、传undefined时，取默认值
当赋值undefined时，取默认值

```
function test(a = 1) {
    console.log(a);
}
test(undefined);    //1
```
#####1.1.5、函数参数不能用用let或const再次声明

不管参数有没有默认值，都不能用let或const再次声明：

```
function test(a = 1) {
    let a = 10;
}
test();    //Uncaught SyntaxError: Identifier 'a' has already been declared
```

#####1.1.6、使用变量时，每次求值使用实时的值
假如函数参数使用函数外的变量，那么每次需要取该参数的默认值时，会去查看该变量的值，再拿来使用，而不是取函数声明时的变量的值；

```
var m = 1;
function test(a = m) {
    console.log(a);
}
test(); //1，查看m，值是1，所以赋值给a，所以a是1
m++;
test(); //2，查看m，此时m已经是2，所以把2赋值给a，所以a是2
```

#####1.1.7、可以使用arguments或this等作为默认值
参数的默认值还可以使用例如arguments，this之类的值。如代码：

```
function test(a = arguments, b = this) {
    console.log(a, b);
}
test(undefined, undefined);
//第一个参数是一个数组，它是arguments（表示所有参数），就像我们直接在函数里面获取这个值一样；
//第二个参数是this，因为直接调用函数，所以this指向window
```

#####1.1.8、注意按引用传递的问题
如果默认值是一个全新对象的话，那么相当于创建了一个新对象赋值给他。<br>
如果是一个变量（该变量指向某个对象），那么是按引用传递。<br>
使用的时候需要略微小心，如示例代码：

```
function test(a = {}) {
    return a;
}
test() === test();  //false

var m = {};
function test(a = m) {
    return a;
}
test() === test();  //true
```
