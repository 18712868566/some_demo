<h3>1、概述</h3>

<h4>1.1、module是什么</h4>

俗称【模块】。

简单来说，假如我写了三个功能，每个功能1000行代码。

如果放在一个js文件里，那就是3000行代码；

如果每个功能放在一个js文件里，那就是各1000行代码。

在往常情况，我们可能需要在html文件里，通过script标签来加载这三个js文件。但这个带来几个问题：

1. 必须依赖html文件；
2. 没有办法做到按需加载（除非你用例如``document.write``或者创建新的DOM标签，之类的方法写入标签）；
3. 不能做到js文件对js文件的依赖关系；
4. 不能做到只暴露指定接口（可以通过立即执行函数返回一个对象，来变相实现，但是很麻烦）；
5. 会污染全局变量；
6. 不方便；

为了解决以上问题，有一些通行的规范，比如**CommonJS**（被Node使用，一般用于服务器端）、**AMD规范**等（一般用于浏览器端）。而ES6也推出了自己的规范。

<h4>1.2、AMD、CMD、CommonJS</h4>

参照这个git链接：[模块化的三种规范，简要说明](https://github.com/qq20004604/some_demo/blob/master/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E4%B8%89%E8%A7%84%E8%8C%83/AMD%E3%80%81CMD%E3%80%81CommonJS.md)

我将之前原本写在这里的内容单独截取出来了，参照上面。

<h4>1.3、es6的模块化</h4>

es6的模块化设计思想有以下特点：

1. 静态化，加载哪些，可以在编译的时候就确定，而不是只有当运行的时候才确定；
2. 编译的时候就能确认依赖关系，这样好优化（缺点是某些模块不确定需不需要用，异步加载需要另外实现，很麻烦）；
3. 通过``export``显式的指定导出的内容，避免全局污染，例如让模块内部的一些东西影响到其他模块；
4. 模块内部的作用域是独立的，不同模块即使有同名变量，只要该变量不影响外部，那么也是互不干扰的；

另外，es6的模块内部，自动启用**【严格模式】**。

<h3>2、import和export</h3>

由于浏览器还不支持import和export，因此需要转码。

转码的教程参照我这篇文章[如何在修改代码后，查阅效果](https://github.com/qq20004604/some_demo/tree/master/ECMA6/es6%E6%A8%A1%E5%9D%97)

