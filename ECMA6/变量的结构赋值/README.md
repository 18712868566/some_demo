#变量的解构赋值

解释：

    1. 简单的来说，可以粗暴地理解为，等号左右两边的数组/结构类似时，将右边的值直接赋给左边对应位置的变量；
    2. 主要面对的是数组和对象；
    3. 虽说数值、字符串以及函数参数也能用，但核心思想是基于数组和对象的，理解好第二点，那么理解后面的也不难；

###**数组的解构赋值**

【1】标准情况：  
等号左右数组结构相同，左边的变量直接拿右边对应位置的变量的值。  
如以下代码；

```javascript
//基本版
var [a,b,c]= [1, 2, 3];
a;    //1
b;    //2
c;    //3
```

左边是一个长度为3的数组，右边也是一个长度为3的数组。  
区别是左边是变量，右边是已知的值。  
这样左右一一对应，变量a、b、c就分别被赋值了；

【2】左右结构相同，但有些位置没有对应的值；  
如以下代码，原本b的位置没有变量了，这样的代码是可以跑通的。

```javascript
//左缺失
var [a,,c]= [1, 2, 3];
a;    //1
c;    //3
```

又如以下代码，左边齐全，但是右边某个位置缺少变量。  
这种情况下，无法对应的变量将被赋值undefined
```javascript
//右缺失，解构不成功但不报错  
var [a,b,c]= [1, , 3];
a;    //1
b;    //undefined
c;    //3
```

【3】数组中嵌套数组  
普通嵌套，一一对应的，此时对应位置对应值，理解起来简单暴力；

```javascript
//数组嵌套  
var [a, [b, c], d]= [1, [2, 3], 4];
a;    //1
b;    //2
c;    //3
d;    //4
```

假如在以上基础上，左右位置有缺少，则如同【2】中缺少的情况一样，变量的值则为undefined，或者右边某个值没有找到左边对应的某个变量。

```javascript
代码略
```

左边和右边非完全对应，如以下代码，则右边非对应的部分可以视为一个整体，或者左边解构失败报错

```javascript
//左边对应右边某个元素  
var [a, b, c]= [1, [2, 3], 4];
a;    //1
b;    //[2,3]，视为整体
c;    //4
```

```javascript
//无法解构，抛出异常
var [a, [b, c], d]= [1, 2, 3];    //Uncaught TypeError: undefined is not a function
```

```javascript
//扩展运算符... （三个句号，更多了解请参照以后的内容）   
var [a, ...b]= [1, 2, 3, 4];
b;    //[2, 3, 4]
```

【4】会报错的情况  
具体来说，右边不是数组（严格的说，不是可遍历的结构），那么将会报错。

```javascript
// 报错的情况 
let [foo] = 1;    //number
let [foo] = false;    //boolean
let [foo] = NaN;    //NaN
let [foo] = undefined;    //undefined
let [foo] = null;    //null
let [foo] = {};    //object
```

这时，我们回过头看【3】中抛出异常的那段代码，之所以报错，是因为实质上是[b, c] = 2，无法结构，所以报错。

【5】var、let、const都适用

【6】对于Set结构，也可以使用其来结构（在Set写完后补充）；

【7】继续拓展，凡是具有Iterator接口的数据结构，都可以使用数组的形式进行结构赋值。  
别问我什么是Iterator接口，请看后面专门讲Iterator的内容。

###**带默认值的数组解构赋值**

解释：

    1. 简单来说，就是在解构赋值时，给一个默认值；
    2. 然后先看能不能解构成功，如果成功则取解构到的值，如果失败则取默认值；

【1】标准情况下：
```javascript
var [a, b = 2, c, d = 10]=[1, , 3, 4];
a;    //1
b;    //2
c;    //3
d;    //4
```
在以上代码中，a和c和普通的解构赋值相同。

除此之外，左边多了一个b = 2和d = 10。于是，b的默认值是2，d的默认值是10，  
而这两者的区别是右边对应解构位置，b的位置对应的是空内容，而d的位置对应的是4

因此，有默认值但解构失败的（准确的说是undefined）b，取了自己的默认值2；  
有默认值但解构成功的的，则取了自己解构成功后的值4；

【2】右边不写和undefined是一样的
```javascript
var [a = 1] = [undefined];  //1
var [a = 1] = [null];   //null
var [a = 1] = [3];  //3
var [a = 1] = ["abc"];  //"abc"
var [a = 1] = [{m: 1}]; //{m:1}
var [a = 1] = [true];   //true
var [a = 1] = [NaN];    //NaN
```

【3】在使用之前已经被声明的变量可以作为默认值使用。

简单来说，假如变量a先被声明，然后作为b解构时的默认值，那么是可以的；

```javascript
var a = 1;
var [b = a] = [];
b;    //1
```

如果你不使用let、const等ES6新规定的声明模式，那么即使你先使用后声明也可以（变量提升），虽然没有什么用，并且不推荐

```javascript
var [b = a] = [];
var a = 1;
b;    //undefined
```

另外，严格模式下，以上这种声明方式不会报错。

###**对象的解构赋值**

解释：

    1. 简单来说，对象解构是根据key给变量赋值该key的val，数组解构是根据顺序给对应位置的变量赋值；

【1】标准情况  
最简单的如以下代码：

```javascript
var {'abc': a} = {'abc': 1};
a;    //1
```

两边都是对象，都有一个key是abc，区别是左边是变量名a，右边的是值1

于是同key的被赋值了。

【2】变量名就是key  
如以下代码，右边有key是abc，左边直接放一个和key相同的变量名，则该变量被赋值同名key的值

```javascript
var {abc} = {'abc': 1};
abc;    //1
```

以上代码的实质是：
```javascript
var {abc: abc} = {'abc': 1};
```
声明时，第一个abc是key，第二个abc是变量名

【3】解构失败，简单来说，就是该变量没有对应的key，取值undefined

```javascript
var {abc} = {};
abc;    //undefined
```

【4】脑洞一下，【1】和【2】情况结合下是什么？  
答案是都起作用
```javascript
var {a: b, a} = {a: 1};
a;    //1
b;    //1
```
第一个a是key，于是变量b被取值；  
第二个a是变量名，所以该变量a被取值1；

【5】对已有变量进行解构赋值  
具体来说，之前我们都是在声明变量时进行结构赋值（注意有var），那么假如已经声明了一个变量，然后进行解构赋值呢？  
答案是可以，但需要用圆括号将解构赋值那段代码括起来。
假如该行没有被括起来，那么就会报错；  

```javascript
var a;
({a} = {a: 1});    //括号括起来 
```

以下代码是可以正常运行的，相当于声明了2次变量a

```javascript
var a;
var {a} = {a: 1};
```

使用let和const时，不能声明两次，否则会报错（见const和let相关内容）

```javascript
let a;
let {a} = {a: 1};    //报错，因为let不能2次
```

```javascript
var a;
var {a} = {a: 1};    //不会报错, 2次var是允许的
```

```javascript
var a;
var {a} = {a: 1};    //不会报错, 2次var是允许的
```



【6】